# 3진법 뒤집기
### 📍 문제 설명
자연수 n이 매개변수로 주어집니다. n을 3진법 상에서 앞뒤로 뒤집은 후, 이를 다시 10진법으로 표현한 수를 return 하도록 solution 함수를 완성해주세요.
### 📍 제한 조건
* n은 1 이상 100,000,000 이하인 자연수입니다.
### 📍 입출력 예
n|result
|---|---|
45|7
125|229

입출력 예 #1<br/>
* 답을 도출하는 과정은 다음과 같습니다.

n(10진법)|n(10진법)|앞뒤 반전(3진법)|10진법으로 표현
---|---|---|---
45|1200|0021|7

* 따라서 7을 return 해야 합니다.

입출력 예 #2
* 답을 도출하는 과정은 다음과 같습니다.

n(10진법)|n(10진법)|앞뒤 반전(3진법)|10진법으로 표현
---|---|---|---
125|11122|22111|229

* 따라서 229를 return 해야 합니다.

# 약수의 합
### 📍 문제 설명
정수 n을 입력받아 n의 약수를 모두 더한 값을 리턴하는 함수, solution을 완성해주세요.
### 📍 제한 조건
* `n`은 0 이상 3000이하인 정수입니다.
### 📍 입출력 예
n|return
|---|---|
12|28
5|6

입출력 예 #1<br/>
12의 약수는 1, 2, 3, 4, 6, 12입니다. 이를 모두 더하면 28입니다.

입출력 예 #2<br/>
5의 약수는 1, 5입니다. 이를 모두 더하면 6입니다.

# 이상한 문자 만들기
### 📍 문제 설명
문자열 s는 한 개 이상의 단어로 구성되어 있습니다. 각 단어는 하나 이상의 공백문자로 구분되어 있습니다. 각 단어의 짝수번째 알파벳은 대문자로, 홀수번째 알파벳은 소문자로 바꾼 문자열을 리턴하는 함수, solution을 완성하세요.
### 📍 제한 조건
* 문자열 전체의 짝/홀수 인덱스가 아니라, 단어(공백을 기준)별로 짝/홀수 인덱스를 판단해야합니다.
* 첫 번째 글자는 0번째 인덱스로 보아 짝수번째 알파벳으로 처리해야 합니다
### 📍 입출력 예
s|return
|---|---|
"try hello world"|"TrY HeLlO WoRlD"

"try hello world"는 세 단어 "try", "hello", "world"로 구성되어 있습니다. 각 단어의 짝수번째 문자를 대문자로, 홀수번째 문자를 소문자로 바꾸면 "TrY", "HeLlO", "WoRlD"입니다. 따라서 "TrY HeLlO WoRlD" 를 리턴합니다.
### 📍 새로 배운 개념
#### 📝  toupper, tolower
[사용 예시]
```
#include <cctype>

int tolower(int c);
int toupper(int c);
```
[예시 코드]
```
#include<ctype.h>
#include<stdio.h>
 
void printInfo(char* pStr)
{
    int len = (int)strlen(pStr);
    
    // 원래 문자열 출력
    printf("original : %s", pStr);
 
    // 소문자로 출력
    printf("\ntolower : ");
    for (int i = 0; i < len; ++i)
    {
        printf("%c", tolower(*(pStr + i)));
    }
 
    // 대문자로 출력
    printf("\ntoupper : ");
    for (int i = 0; i < len; ++i)
    {
        printf("%c", toupper(*(pStr + i)));
    }
 
    printf("\n\n");
}
 
int main(void)
{
    char str1[] = "BlockDMask Blog";
    char str2[] = "1 2 3 4 5 6";
    char str3[] = "!@#$%^, aBcDeFg 12345";
 
    printInfo(str1);
    printInfo(str2);
    printInfo(str3);
 
    return 0;
}
```
[참고 링크](https://blockdmask.tistory.com/452)

# 자릿수 더하기
### 📍 문제 설명
자연수 N이 주어지면, N의 각 자릿수의 합을 구해서 return 하는 solution 함수를 만들어 주세요.

예를들어 N = 123이면 1 + 2 + 3 = 6을 return 하면 됩니다.
### 📍 제한 조건
* N의 범위 : 100,000,000 이하의 자연수
### 📍 입출력 예
N|answer
|---|---|
123|6
987|24

입출력 예 #1
문제의 예시와 같습니다.

입출력 예 #2
9 + 8 + 7 = 24이므로 24를 return 하면 됩니다.

# 자연수 뒤집어 배열로 만들기
### 📍 문제 설명
자연수 n을 뒤집어 각 자리 숫자를 원소로 가지는 배열 형태로 리턴해주세요. 예를들어 n이 12345이면 [5,4,3,2,1]을 리턴합니다.
### 📍 제한 조건
* n은 10,000,000,000이하인 자연수입니다.
### 📍 입출력 예
n|return
|---|---|
12345|[5,4,3,2,1]

# 정수 내림차순으로 배치하기
### 📍 문제 설명
함수 solution은 정수 n을 매개변수로 입력받습니다. n의 각 자릿수를 큰것부터 작은 순으로 정렬한 새로운 정수를 리턴해주세요. 예를들어 n이 118372면 873211을 리턴하면 됩니다.
### 📍 제한 조건
* `n`은 1이상 8000000000 이하인 자연수입니다.
### 📍 입출력 예
n|return
|---|---|
118372|873211

# 정수 제곱근 판별
### 📍 문제 설명
임의의 양의 정수 n에 대해, n이 어떤 양의 정수 x의 제곱인지 아닌지 판단하려 합니다.

n이 양의 정수 x의 제곱이라면 x+1의 제곱을 리턴하고, n이 양의 정수 x의 제곱이 아니라면 -1을 리턴하는 함수를 완성하세요.
### 📍 제한 조건
* n은 1이상, 50000000000000 이하인 양의 정수입니다.
### 📍 입출력 예
n|return
|---|---|
122|144
3|-1

입출력 예#1<br/>
121은 양의 정수 11의 제곱이므로, (11+1)를 제곱한 144를 리턴합니다.

입출력 예#2<br/>
3은 양의 정수의 제곱이 아니므로, -1을 리턴합니다.

# 제일 작은 수 제거하기
### 📍 문제 설명
정수를 저장한 배열, arr 에서 가장 작은 수를 제거한 배열을 리턴하는 함수, solution을 완성해주세요. 단, 리턴하려는 배열이 빈 배열인 경우엔 배열에 -1을 채워 리턴하세요. 예를들어 arr이 [4,3,2,1]인 경우는 [4,3,2]를 리턴 하고, [10]면 [-1]을 리턴 합니다.
### 📍 제한 조건
* arr은 길이 1 이상인 배열입니다.
* 인덱스 i, j에 대해 i ≠ j이면 arr[i] ≠ arr[j] 입니다.
### 📍 입출력 예
arr|return
|---|---|
[4,3,2,1]|[4,3,2]
[10]|[-1]